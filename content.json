{"posts":[{"title":"Hexo常用指令大全","text":"Hexo 常用命令速查表 命令 功能 常用参数/示例 初始化 npm install -g hexo-cli 全局安装Hexo命令行工具 hexo init &lt;folder&gt; 初始化博客项目 hexo init myblog npm install 安装依赖包（在项目目录执行） 内容管理 hexo new &quot;标题&quot; 新建文章 hexo new &quot;Hello World&quot; hexo new page &quot;名称&quot; 新建页面 hexo new page &quot;about&quot; hexo publish &lt;filename&gt; 发布草稿 hexo publish draft/untitled.md 生成与预览 hexo generate 生成静态文件（简写hexo g） hexo g --watch（监听文件变化） hexo server 启动本地服务器（简写hexo s） hexo s -p 5000（指定端口） hexo clean 清除缓存和生成文件 常与生成命令组合使用 部署 npm install hexo-deployer-git --save 安装Git部署插件 hexo deploy 部署到服务器（简写hexo d） hexo d --generate（先生成后部署） 组合命令 hexo g -d 生成后立即部署 常用部署组合 hexo s -g 生成后启动服务器 开发调试常用 高级操作 hexo list &lt;type&gt; 列出所有文章/页面等 hexo list post hexo version 查看Hexo版本 hexo --config custom.yml 使用自定义配置文件 多环境配置时使用 典型工作流示例 12345678# 1. 创建新文章hexo new &quot;深入理解Hexo架构&quot;# 2. 本地写作并预览hexo clean &amp;&amp; hexo g &amp;&amp; hexo s# 3. 部署到GitHubhexo clean &amp;&amp; hexo g -d 配置注意要点 部署配置（_config.yml） 1234deploy: type: git repo: https://github.com/用户名/仓库名.git branch: gh-pages 主题配置示例 1theme: icarus # 需先安装主题到themes目录 常用插件推荐 插件 功能 安装命令 hexo-abbrlink 生成永久链接 npm install hexo-abbrlink --save hexo-all-minifier 压缩静态资源 npm install hexo-all-minifier --save hexo-generator-search 添加本地搜索 npm install hexo-generator-search --save 掌握这些命令可提升博客管理效率，建议结合--debug参数排查问题： 1hexo g --debug # 显示详细生成日志 icarus教程:https://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/","link":"/posts/Hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"title":"redis基础结构","text":"Redis入门 （NoSQL, Not Only SQL） 非关系型数据库 关系型数据库：以 表格 的形式存在，以 行和列 的形式存取数据，一系列的行和列被称为表，无数张表组成了 数据库。支持复杂的 SQL 查询，能够体现出数据之间、表之间的关联关系；也支持事务，便于提交或者回滚。 非关系型数据库：以 key-value 的形式存在，可以想象成电话本的形式，人名（key）对应电话号码（value）。不需要写一些复杂的 SQL 语句，不需要经过 SQL 的重重解析，性能很高；可扩展性也比较强，数据之间没有耦合性，需要新加字段就直接增加一个 key-value 键值对即可。 Redis 是 速度极快的、基于内存的，键值型 NoSQL 数据库。 为什么这么快？ 完全基于内存操作。 使用非阻塞的 IO 多路复用机制。 数据结构简单，对数据操作也简单。 使用单线程，避免了上下文切换和竞争产生的消耗。 支持多种数据类型，包括 String、Hash、List、Set、ZSet 等。 IO 多路复用机制 Redis 使用的是 IO 多路复用机制 来处理 高并发请求，这使得它能在 单线程 模式下仍然保持高吞吐量。 🔹 Redis 为什么要用 IO 多路复用？ Redis 是单线程的，但仍然能高效处理大量连接，这依赖于 IO 多路复用。 传统的 阻塞 IO 方式，每次只能处理一个连接，性能受限。 多路复用可以 同时监听多个客户端请求，只处理活跃连接，减少 CPU 空转。 🔹 Redis 的 IO 多路复用机制 Redis 采用 epoll（Linux）或 select（Windows） 作为 IO 多路复用技术，主要使用 aeEventLoop 事件处理机制： 主线程通过 epoll/select/kqueue 监听多个客户端连接 当某个连接有数据可读（如命令请求），Redis 触发相应的回调函数 回调函数读取请求，处理命令，返回结果 继续监听新的请求，不会阻塞在某个请求上 Redis 使用 事件驱动模型，主要有： 可读事件（AE_READABLE）：当客户端有数据可读时触发。 可写事件（AE_WRITABLE）：当客户端可以写数据时触发。 文件事件（File Event）：通过 epoll 监听 多个 socket 连接。 时间事件（Time Event）：用于定时任务（比如 key 过期检测）。 🔹 Redis 多路复用示意图 1234567891011[多个客户端] │ ▼[epoll/select 监听] │ ├── 客户端 A 可读 -&gt; 触发回调 -&gt; 读取数据 ├── 客户端 B 可写 -&gt; 触发回调 -&gt; 发送数据 ├── 客户端 C 可读 -&gt; 触发回调 -&gt; 读取数据 │ ▼[主线程执行 Redis 命令逻辑] Redis的基础结构类型 Key结构 让 Redis 的 key 形成层级结构，使用 : 隔开：项目名:业务名:类型:id。 123set blog:user:1 '{&quot;id&quot;:1, &quot;name&quot;:&quot;Jack&quot;, &quot;age&quot;:22}'set blog:user:2 '{&quot;id&quot;:2, &quot;name&quot;:&quot;Mike&quot;, &quot;age&quot;:23}'set blog:article:1 '{&quot;id&quot;:1, &quot;title&quot;:&quot;Spring&quot;}' String类型 Key Value blog:user:1 ‘{“id”:1, “name”:“Jack”, “age”:22}’ blog:user:2 ‘{“id”:2, “name”:“Mike”, “age”:23}’ 分配策略： Java 的 String 是不可变的，无法修改。Redis 的 String 是动态的，可以修改的。Redis 的 String 在内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。如图所示，当前字符串实际分配的空间为 capacity，一般高于实际的字符串长度 len。当字符串长度小于 1M 时，扩容是对现有空间的成倍增长；如果长度超过 1M 时，扩容一次只会多增加 1M 的空间。String 的最大长度为 512M。 Hash结构 list结构 List 类似 Java 中的 LinkedList，可以看作一个双向链表（有序可重复）。使用 List 可以对链表的两端进行 push 和 pop 操作、读取单个或多个元素、根据值查找或删除元素、支持正向检索和反向检索。 栈：LPUSH + LPOP 或 RPUSH + RPOP。 队列：LPUSH + RPOP 或 RPUSH + LPOP。 Set结构 SADD key member [member ...] ：向 Set 中添加一个或多个元素。 SMEMBERS key ：获取指定 Set 中的所有元素。 SISMEMBER key member ：判断 Set 中是否存在指定元素。 SCARD key ：返回 Set 中的元素个数。 SREM key member [member ...] ：移除 Set 中的指定元素。 SINTER key [key ...] ：求 n 个 key 间的交集。 SDIFF key [key ...] ：求 n 个 key 间的差集。 SUNION key [key ...] ：求 n 个 key 间的并集。 Redis 的 Set 类似 HashSet，可以看作一个 value 为 null 的 HashMap；其特征也与 HashSet 类似：无序不可重复，支持 交集、并集、差集等功能。 ZSet Redis 的 ZSet 是一个可排序的 Set 集合，类似 ZSet。ZSet 的每一个元素都带有一个 score 属性，可以基于 score 属性对元素排序。 ZADD key [score member ...] ：以 score 为权重向 ZSet 中添加一个或多个元素，如果存在则更新 score。 ZREM key member [member ...] ：删除 ZSet 中的指定元素。 ZCARD key ：返回 ZSet 中的元素个数。 ZSCORE key member ：获取 ZSet 中指定元素的 score 值。 ZADD key [score member ...] ：以 score 为权重向 ZSet 中添加一个或多个元素，如果存在则更新 score。 ZREM key member [member ...] ：删除 ZSet 中的指定元素。 ZCARD key ：返回 ZSet 中的元素个数。 ZSCORE key member ：获取 ZSet 中指定元素的 score 值。 ZRANGEBYSCORE key min max ：按照 score 排序后，获取 指定 score 范围 内的元素。 ZINTER numberKeys key [key ...] ｜ ZDIFF numberKeys key [key ...] ｜ ZUNION numberKeys key [key ...] ：求 n 个 Zset 的交集、差集、并集。 Redis 基础结构及其操作指令总结 基础结构 描述 常用指令 示例 String（字符串） 最基本的数据结构，可以存储字符串、整数或浮点数 SET、GET、INCR、DECR、APPEND、MSET、MGET SET key value，GET key List（列表） 有序集合，允许重复元素，底层为双向链表 LPUSH、RPUSH、LPOP、RPOP、LRANGE LPUSH mylist A B C，LRANGE mylist 0 -1 Set（集合） 无序集合，不允许重复元素 SADD、SREM、SMEMBERS、SISMEMBER SADD myset A B C，SMEMBERS myset Hash（哈希） 类似于对象，存储键值对 HSET、HGET、HGETALL、HDEL HSET user name &quot;Alice&quot;，HGET user name ZSet（有序集合） 具有权重（score）的集合，元素按分数排序 ZADD、ZRANGE、ZREM、ZSCORE ZADD myzset 1 A 2 B，ZRANGE myzset 0 -1 Bitmap（位图） 位级别的存储，用于高效存储和操作二进制数据 SETBIT、GETBIT、BITCOUNT SETBIT mybitmap 10 1，GETBIT mybitmap 10 HyperLogLog 近似去重计数结构，适用于大数据计数 PFADD、PFCOUNT PFADD myhll A B C，PFCOUNT myhll Geo（地理位置） 存储经纬度并计算地理距离 GEOADD、GEODIST、GEORADIUS GEOADD mygeo 120.0 30.0 &quot;place1&quot;，GEODIST mygeo place1 place2 Stream（流） 可持久化的消息队列结构 XADD、XLEN、XREAD XADD mystream * name &quot;Alice&quot;，XREAD COUNT 1 STREAMS mystream 0 这些结构和指令在不同的应用场景中有不同的优势，比如 String 适用于缓存数据，List 适用于消息队列，Set 适用于去重，ZSet 适用于排行榜，Hash 适用于存储对象，Bitmap 适用于用户签到或活跃记录，HyperLogLog 适用于大规模数据去重统计，Geo 适用于地理位置存储，Stream 适用于事件流和消息队列。 java客户端连接redis 使用Jedis 1.导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt;&lt;/dependency&gt; 2.建立连接 12345678910111213141516171819202122232425262728293031public class JedisTest { private Jedis jedis; @BeforeEach void setUp(){ //1.建立连接 jedis = new Jedis(&quot;192.168.200.130&quot;,6379); //2.设置密码 jedis.auth(&quot;1234&quot;); //3.选择库 jedis.select(0); } @Test void testString(){ String result = jedis.set(&quot;name&quot;, &quot;小明&quot;); System.out.println(&quot;result= &quot; + result); String name = jedis.get(&quot;name&quot;); System.out.println(&quot;name= &quot;+name); } @AfterEach void tearDown(){ if(jedis!=null){ jedis.close(); } }} 3.jedis连接池 12345678910111213141516171819public class JedisConnectFactory { private static final JedisPool jedisPool; static{ //配置连接池 JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(8); poolConfig.setMaxIdle(8); poolConfig.setMinIdle(0); poolConfig.setMaxWait(Duration.ofMillis(1000)); jedisPool = new JedisPool(poolConfig,&quot;192.168.200.130&quot;,6379,1000,&quot;1234&quot;); } public static Jedis getJedis(){ return jedisPool.getResource(); }} 1） JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式 2）静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化 3）最后提供返回连接池中连接的方法. 使用springDataRedis连接 1.导入依赖 12345678910&lt;!--Redis依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--连接池依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt; 2.配置连接信息 123456789101112spring: redis: host: 192.168.200.130 port: 6379 password: 1234 database: 0 lettuce: pool: max-active: 8 #最大连接数 max-idle: 8 #最大空闲连接 min-idle: 0 #最小空闲连接 max-wait: 100 #连接等待时间 3.直接注入RedisTemplate出现的问题 123456789101112131415161718192021222324252627// 自动注入的 `RedisTemplate` 需要加上泛型@Resourceprivate RedisTemplate redisTemplate;@Testpublic void test() { redisTemplate.opsForValue().set(&quot;k1&quot;, &quot;v1&quot;); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;k2&quot;, &quot;v2&quot;); map.put(&quot;k3&quot;, &quot;v3&quot;); map.put(&quot;k4&quot;, &quot;v4&quot;); map.put(&quot;k5&quot;, &quot;v5&quot;); redisTemplate.opsForValue().multiSet(map); redisTemplate.opsForValue().multiGet(Arrays.asList(&quot;k1&quot;, &quot;k2&quot;, &quot;k3&quot;, &quot;k4&quot;)).forEach(System.out::println); // v1 v2 v3 v4 v5}//结果# 在 Redis 中查看通过 RedisTemplate 插入的数据&gt; keys *1) &quot;\\xac\\xed\\x00\\x05t\\x00\\x02k1&quot;2) &quot;\\xac\\xed\\x00\\x05t\\x00\\x02k2&quot;3) &quot;\\xac\\xed\\x00\\x05t\\x00\\x02k3&quot;4) &quot;\\xac\\xed\\x00\\x05t\\x00\\x02k4&quot;5) &quot;\\xac\\xed\\x00\\x05t\\x00\\x02k5&quot;&gt; get &quot;\\xac\\xed\\x00\\x05t\\x00\\x02k1&quot;&quot;\\xac\\xed\\x00\\x05t\\x00\\x02v1&quot; RedisTemplate 存在的问题 通过以上操作可以发现：RedisTemplate 可以将任意类型的数据写入到 Redis 中，在写入前会将其序列化为字节形式存储，底层默认采用 ObjectOutputStream 序列化。 4.因此我们要重写他的序列化工具 导入 jackson-databind 依赖，并编写配置类 RedisTemplateConfig。 12345678910111213141516171819202122@Configurationpublic class RedisTemplateConfig { @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) { // 创建 RedisTemplate 对象 RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); // 设置连接工厂 redisTemplate.setConnectionFactory(redisConnectionFactory); // 设置序列化工具 GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); // Key 和 HashKey 采用 String 序列化（StringRedisSerializer） redisTemplate.setKeySerializer(RedisSerializer.string()); redisTemplate.setHashKeySerializer(RedisSerializer.string()); // Value 和 HashValue 采用 JSON 序列化（GenericJackson2JsonRedisSerializer） redisTemplate.setValueSerializer(jsonRedisSerializer); redisTemplate.setHashValueSerializer(jsonRedisSerializer); return redisTemplate; }} 12345678910// 自动注入的 `RedisTemplate` 需要加上泛型@Autowiredprivate RedisTemplate&lt;String, Object&gt; redisTemplate;@Testpublic void test() { redisTemplate.opsForValue().set(&quot;k1&quot;, &quot;v1&quot;); redisTemplate.opsForValue().set(&quot;user:1&quot;, new User(&quot;Jack&quot;, 21));} 通过以上的方法能够解决数据序列化时 可读性差、内存占用大 的问题。 但是 JSON 的序列化方式仍然存在一些问题：为了反序列化时知道对象的类型，JSON 序列化器会将类的 class 类型写入 JSON 结果，存入 Redis 中，会带来额外的内存开销。 5.使用StringRedisTemplate 为了节省内存空间，Spring 提供了一个 StringRedisTemplate，它的 key 和 value 的序列化方式默认就是 String，统一使用 String 序列化器。 当需要存储 Java 对象时，手动完成对象的序列化和反序列化。 使用 StringRedisTemplate。 写入数据到 Redis 中，手动将对象序列化为 JSON。 从 Redis 中读取数据，手动将读取到的 JSON 反序列化为对象。 123456789101112131415161718192021222324@Autowiredprivate StringRedisTemplate stringRedisTemplate;private static final ObjectMapper objectMapper = new ObjectMapper();@Testpublic void ttt() throws JsonProcessingException { User user = new User(&quot;Michael&quot;, 27); // 手动序列化 String json = objectMapper.writeValueAsString(user); // 写入数据 stringRedisTemplate.opsForValue().set(&quot;user:1&quot;, json); // 读取数据 String data = stringRedisTemplate.opsForValue().get(&quot;user:1&quot;); // 反序列化 User deserializedUser = objectMapper.readValue(data, User.class); System.out.println(deserializedUser);}//结果{ &quot;username&quot;: &quot;Michael&quot;, &quot;age&quot;: 27}","link":"/posts/redis%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"redis","slug":"redis","link":"/tags/redis/"}],"categories":[{"name":"Hexo教程","slug":"Hexo教程","link":"/categories/Hexo%E6%95%99%E7%A8%8B/"},{"name":"redis笔记","slug":"redis笔记","link":"/categories/redis%E7%AC%94%E8%AE%B0/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"}]}